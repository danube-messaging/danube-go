// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             v3.21.12
// source: SchemaRegistry.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SchemaRegistry_RegisterSchema_FullMethodName              = "/danube_schema.SchemaRegistry/RegisterSchema"
	SchemaRegistry_GetSchema_FullMethodName                   = "/danube_schema.SchemaRegistry/GetSchema"
	SchemaRegistry_GetLatestSchema_FullMethodName             = "/danube_schema.SchemaRegistry/GetLatestSchema"
	SchemaRegistry_ListVersions_FullMethodName                = "/danube_schema.SchemaRegistry/ListVersions"
	SchemaRegistry_CheckCompatibility_FullMethodName          = "/danube_schema.SchemaRegistry/CheckCompatibility"
	SchemaRegistry_DeleteSchemaVersion_FullMethodName         = "/danube_schema.SchemaRegistry/DeleteSchemaVersion"
	SchemaRegistry_SetCompatibilityMode_FullMethodName        = "/danube_schema.SchemaRegistry/SetCompatibilityMode"
	SchemaRegistry_ConfigureTopicSchema_FullMethodName        = "/danube_schema.SchemaRegistry/ConfigureTopicSchema"
	SchemaRegistry_UpdateTopicValidationPolicy_FullMethodName = "/danube_schema.SchemaRegistry/UpdateTopicValidationPolicy"
	SchemaRegistry_GetTopicSchemaConfig_FullMethodName        = "/danube_schema.SchemaRegistry/GetTopicSchemaConfig"
)

// SchemaRegistryClient is the client API for SchemaRegistry service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Schema Registry Service for managing schemas across the Danube cluster
type SchemaRegistryClient interface {
	// Register a new schema or get existing schema ID if identical schema exists
	RegisterSchema(ctx context.Context, in *RegisterSchemaRequest, opts ...grpc.CallOption) (*RegisterSchemaResponse, error)
	// Get a specific schema by ID and optional version
	GetSchema(ctx context.Context, in *GetSchemaRequest, opts ...grpc.CallOption) (*GetSchemaResponse, error)
	// Get the latest version of a schema for a subject
	GetLatestSchema(ctx context.Context, in *GetLatestSchemaRequest, opts ...grpc.CallOption) (*GetSchemaResponse, error)
	// List all versions for a subject
	ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (*ListVersionsResponse, error)
	// Check if a new schema is compatible with existing versions
	CheckCompatibility(ctx context.Context, in *CheckCompatibilityRequest, opts ...grpc.CallOption) (*CheckCompatibilityResponse, error)
	// Delete a specific schema version
	DeleteSchemaVersion(ctx context.Context, in *DeleteSchemaVersionRequest, opts ...grpc.CallOption) (*DeleteSchemaVersionResponse, error)
	// Set or update compatibility mode for a subject
	SetCompatibilityMode(ctx context.Context, in *SetCompatibilityModeRequest, opts ...grpc.CallOption) (*SetCompatibilityModeResponse, error)
	// Configure schema settings for a topic (admin-only)
	// Allows admin to assign/change schema subject and validation settings
	ConfigureTopicSchema(ctx context.Context, in *ConfigureTopicSchemaRequest, opts ...grpc.CallOption) (*ConfigureTopicSchemaResponse, error)
	// Update validation policy for a topic (admin-only)
	UpdateTopicValidationPolicy(ctx context.Context, in *UpdateTopicValidationPolicyRequest, opts ...grpc.CallOption) (*UpdateTopicValidationPolicyResponse, error)
	// Get current schema configuration for a topic
	GetTopicSchemaConfig(ctx context.Context, in *GetTopicSchemaConfigRequest, opts ...grpc.CallOption) (*GetTopicSchemaConfigResponse, error)
}

type schemaRegistryClient struct {
	cc grpc.ClientConnInterface
}

func NewSchemaRegistryClient(cc grpc.ClientConnInterface) SchemaRegistryClient {
	return &schemaRegistryClient{cc}
}

func (c *schemaRegistryClient) RegisterSchema(ctx context.Context, in *RegisterSchemaRequest, opts ...grpc.CallOption) (*RegisterSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterSchemaResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_RegisterSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) GetSchema(ctx context.Context, in *GetSchemaRequest, opts ...grpc.CallOption) (*GetSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSchemaResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_GetSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) GetLatestSchema(ctx context.Context, in *GetLatestSchemaRequest, opts ...grpc.CallOption) (*GetSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSchemaResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_GetLatestSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (*ListVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVersionsResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_ListVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) CheckCompatibility(ctx context.Context, in *CheckCompatibilityRequest, opts ...grpc.CallOption) (*CheckCompatibilityResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CheckCompatibilityResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_CheckCompatibility_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) DeleteSchemaVersion(ctx context.Context, in *DeleteSchemaVersionRequest, opts ...grpc.CallOption) (*DeleteSchemaVersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSchemaVersionResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_DeleteSchemaVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) SetCompatibilityMode(ctx context.Context, in *SetCompatibilityModeRequest, opts ...grpc.CallOption) (*SetCompatibilityModeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetCompatibilityModeResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_SetCompatibilityMode_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) ConfigureTopicSchema(ctx context.Context, in *ConfigureTopicSchemaRequest, opts ...grpc.CallOption) (*ConfigureTopicSchemaResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConfigureTopicSchemaResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_ConfigureTopicSchema_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) UpdateTopicValidationPolicy(ctx context.Context, in *UpdateTopicValidationPolicyRequest, opts ...grpc.CallOption) (*UpdateTopicValidationPolicyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateTopicValidationPolicyResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_UpdateTopicValidationPolicy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *schemaRegistryClient) GetTopicSchemaConfig(ctx context.Context, in *GetTopicSchemaConfigRequest, opts ...grpc.CallOption) (*GetTopicSchemaConfigResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetTopicSchemaConfigResponse)
	err := c.cc.Invoke(ctx, SchemaRegistry_GetTopicSchemaConfig_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SchemaRegistryServer is the server API for SchemaRegistry service.
// All implementations must embed UnimplementedSchemaRegistryServer
// for forward compatibility.
//
// Schema Registry Service for managing schemas across the Danube cluster
type SchemaRegistryServer interface {
	// Register a new schema or get existing schema ID if identical schema exists
	RegisterSchema(context.Context, *RegisterSchemaRequest) (*RegisterSchemaResponse, error)
	// Get a specific schema by ID and optional version
	GetSchema(context.Context, *GetSchemaRequest) (*GetSchemaResponse, error)
	// Get the latest version of a schema for a subject
	GetLatestSchema(context.Context, *GetLatestSchemaRequest) (*GetSchemaResponse, error)
	// List all versions for a subject
	ListVersions(context.Context, *ListVersionsRequest) (*ListVersionsResponse, error)
	// Check if a new schema is compatible with existing versions
	CheckCompatibility(context.Context, *CheckCompatibilityRequest) (*CheckCompatibilityResponse, error)
	// Delete a specific schema version
	DeleteSchemaVersion(context.Context, *DeleteSchemaVersionRequest) (*DeleteSchemaVersionResponse, error)
	// Set or update compatibility mode for a subject
	SetCompatibilityMode(context.Context, *SetCompatibilityModeRequest) (*SetCompatibilityModeResponse, error)
	// Configure schema settings for a topic (admin-only)
	// Allows admin to assign/change schema subject and validation settings
	ConfigureTopicSchema(context.Context, *ConfigureTopicSchemaRequest) (*ConfigureTopicSchemaResponse, error)
	// Update validation policy for a topic (admin-only)
	UpdateTopicValidationPolicy(context.Context, *UpdateTopicValidationPolicyRequest) (*UpdateTopicValidationPolicyResponse, error)
	// Get current schema configuration for a topic
	GetTopicSchemaConfig(context.Context, *GetTopicSchemaConfigRequest) (*GetTopicSchemaConfigResponse, error)
	mustEmbedUnimplementedSchemaRegistryServer()
}

// UnimplementedSchemaRegistryServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSchemaRegistryServer struct{}

func (UnimplementedSchemaRegistryServer) RegisterSchema(context.Context, *RegisterSchemaRequest) (*RegisterSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterSchema not implemented")
}
func (UnimplementedSchemaRegistryServer) GetSchema(context.Context, *GetSchemaRequest) (*GetSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSchema not implemented")
}
func (UnimplementedSchemaRegistryServer) GetLatestSchema(context.Context, *GetLatestSchemaRequest) (*GetSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetLatestSchema not implemented")
}
func (UnimplementedSchemaRegistryServer) ListVersions(context.Context, *ListVersionsRequest) (*ListVersionsResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListVersions not implemented")
}
func (UnimplementedSchemaRegistryServer) CheckCompatibility(context.Context, *CheckCompatibilityRequest) (*CheckCompatibilityResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CheckCompatibility not implemented")
}
func (UnimplementedSchemaRegistryServer) DeleteSchemaVersion(context.Context, *DeleteSchemaVersionRequest) (*DeleteSchemaVersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteSchemaVersion not implemented")
}
func (UnimplementedSchemaRegistryServer) SetCompatibilityMode(context.Context, *SetCompatibilityModeRequest) (*SetCompatibilityModeResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SetCompatibilityMode not implemented")
}
func (UnimplementedSchemaRegistryServer) ConfigureTopicSchema(context.Context, *ConfigureTopicSchemaRequest) (*ConfigureTopicSchemaResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ConfigureTopicSchema not implemented")
}
func (UnimplementedSchemaRegistryServer) UpdateTopicValidationPolicy(context.Context, *UpdateTopicValidationPolicyRequest) (*UpdateTopicValidationPolicyResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateTopicValidationPolicy not implemented")
}
func (UnimplementedSchemaRegistryServer) GetTopicSchemaConfig(context.Context, *GetTopicSchemaConfigRequest) (*GetTopicSchemaConfigResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetTopicSchemaConfig not implemented")
}
func (UnimplementedSchemaRegistryServer) mustEmbedUnimplementedSchemaRegistryServer() {}
func (UnimplementedSchemaRegistryServer) testEmbeddedByValue()                        {}

// UnsafeSchemaRegistryServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SchemaRegistryServer will
// result in compilation errors.
type UnsafeSchemaRegistryServer interface {
	mustEmbedUnimplementedSchemaRegistryServer()
}

func RegisterSchemaRegistryServer(s grpc.ServiceRegistrar, srv SchemaRegistryServer) {
	// If the following call panics, it indicates UnimplementedSchemaRegistryServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SchemaRegistry_ServiceDesc, srv)
}

func _SchemaRegistry_RegisterSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).RegisterSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_RegisterSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).RegisterSchema(ctx, req.(*RegisterSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_GetSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).GetSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_GetSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).GetSchema(ctx, req.(*GetSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_GetLatestSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).GetLatestSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_GetLatestSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).GetLatestSchema(ctx, req.(*GetLatestSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_ListVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).ListVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_ListVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).ListVersions(ctx, req.(*ListVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_CheckCompatibility_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckCompatibilityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).CheckCompatibility(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_CheckCompatibility_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).CheckCompatibility(ctx, req.(*CheckCompatibilityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_DeleteSchemaVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSchemaVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).DeleteSchemaVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_DeleteSchemaVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).DeleteSchemaVersion(ctx, req.(*DeleteSchemaVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_SetCompatibilityMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCompatibilityModeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).SetCompatibilityMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_SetCompatibilityMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).SetCompatibilityMode(ctx, req.(*SetCompatibilityModeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_ConfigureTopicSchema_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigureTopicSchemaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).ConfigureTopicSchema(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_ConfigureTopicSchema_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).ConfigureTopicSchema(ctx, req.(*ConfigureTopicSchemaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_UpdateTopicValidationPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTopicValidationPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).UpdateTopicValidationPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_UpdateTopicValidationPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).UpdateTopicValidationPolicy(ctx, req.(*UpdateTopicValidationPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SchemaRegistry_GetTopicSchemaConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicSchemaConfigRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SchemaRegistryServer).GetTopicSchemaConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SchemaRegistry_GetTopicSchemaConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SchemaRegistryServer).GetTopicSchemaConfig(ctx, req.(*GetTopicSchemaConfigRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SchemaRegistry_ServiceDesc is the grpc.ServiceDesc for SchemaRegistry service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SchemaRegistry_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "danube_schema.SchemaRegistry",
	HandlerType: (*SchemaRegistryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterSchema",
			Handler:    _SchemaRegistry_RegisterSchema_Handler,
		},
		{
			MethodName: "GetSchema",
			Handler:    _SchemaRegistry_GetSchema_Handler,
		},
		{
			MethodName: "GetLatestSchema",
			Handler:    _SchemaRegistry_GetLatestSchema_Handler,
		},
		{
			MethodName: "ListVersions",
			Handler:    _SchemaRegistry_ListVersions_Handler,
		},
		{
			MethodName: "CheckCompatibility",
			Handler:    _SchemaRegistry_CheckCompatibility_Handler,
		},
		{
			MethodName: "DeleteSchemaVersion",
			Handler:    _SchemaRegistry_DeleteSchemaVersion_Handler,
		},
		{
			MethodName: "SetCompatibilityMode",
			Handler:    _SchemaRegistry_SetCompatibilityMode_Handler,
		},
		{
			MethodName: "ConfigureTopicSchema",
			Handler:    _SchemaRegistry_ConfigureTopicSchema_Handler,
		},
		{
			MethodName: "UpdateTopicValidationPolicy",
			Handler:    _SchemaRegistry_UpdateTopicValidationPolicy_Handler,
		},
		{
			MethodName: "GetTopicSchemaConfig",
			Handler:    _SchemaRegistry_GetTopicSchemaConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "SchemaRegistry.proto",
}
